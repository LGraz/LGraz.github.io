{
  "hash": "62a2512c0607cddfb2950b06abdc0070",
  "result": {
    "markdown": "---\nTitle: \"Bad Coverage for exponential GLMs\"\nauthor: Lukas Graz\ndate: 2023-07-12\npermalink: /posts/exponential-glm-coverage\ntags: \n  - simulation\n  - power\n---\n\nSimulate a `glm` with exponential distribution such that \n\n$$\\operatorname{y} \\sim \\operatorname{exp}(\\operatorname{h}(\\alpha + 1\\operatorname{x} + 2\\operatorname{z}))$$\n\nwith the $h$ being the inverse of the link functions:\n- identity\n- inverse\n- log\n\n## Setup\n\n::: {.cell hash='exponential-glm-coverage_cache/commonmark/unnamed-chunk-1_4a8938f1dc6f09ad9fc46b87a1098199'}\n\n```{.r .cell-code}\ninv_links <- list( \n  identity = function(eta) eta,\n  inverse = function(eta) 1/eta,\n  log = exp)\n\nget_data <- function(inv_link){\n  x <- pmin(pmax(0, rnorm(n, 2)), 4)\n  z <- pmin(pmax(0, rnorm(n, 1)), 4)\n  eta <- 1 + x + 2*z\n  data.frame(\n    x=x, \n    z=z, \n    eta=eta, \n    mu=inv_link(eta), \n    y=rgamma(n, shape=1, scale=inv_link(eta))\n  )\n}\n\nis.in.confint <- function(x, I) (x >I[1]) && (x< I[2])\n```\n:::\n\n\n\n## Simulation\nFor each link function:\n1. Plot an example (green line is the true expectation and red line is a smoothing spline)\n2. Simulate coverage of true parameter for `x` (should be 95%)\n\n::: {.cell hash='exponential-glm-coverage_cache/commonmark/unnamed-chunk-2_209bf8360096f24ddb9e1730e303a3e7'}\n\n```{.r .cell-code}\nn <- 1000 # sample size\nnsim <- 1000 # number of simulations to test the confidence interval\nset.seed(123)\nfor (i in seq_along(inv_links)){\n  D <- get_data(inv_links[[i]])\n  \n  plot(y ~ mu, main=names(inv_links)[i], data=D)\n  # Test with SmoothingSplines if indeed: E(y|mu) = mu\n  with(D, lines(smooth.spline(mu, y), col='red'))\n  abline(0,1, col='green')\n\n  f <- glm(y ~ x + z, data=D, family=Gamma(link=names(inv_links)[i]), mustart=mu)\n\n  # see if the conf-interval for beta_x is valid. i.e.:\n  #    repeat it nsim times and see if 1 is in our confidence interval\n  R <- mcreplicate::mc_replicate(nsim,{\n    try({\n      D <- get_data(inv_links[[i]])\n      s <- summary(f <- glm(\n        y ~ x + z, \n        data = D,\n        family = Gamma(link = names(inv_links)[i]), \n        mustart = mu)); s\n      suppressMessages(is.in.confint(1, confint(f, \"x\")))\n    }, silent = TRUE)\n  })\n  coverage <- mean(as.logical(R), na.rm=TRUE)\n  cat(sprintf(\"Coverage for %s: %f\\n\", names(inv_links)[i], coverage))\n}\n```\n\n::: {.cell-output-display}\n![](exponential-glm-coverage_files/figure-commonmark/unnamed-chunk-2-1.png)\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCoverage for identity: 0.939000\n```\n:::\n\n::: {.cell-output-display}\n![](exponential-glm-coverage_files/figure-commonmark/unnamed-chunk-2-2.png)\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCoverage for inverse: 0.942000\n```\n:::\n\n::: {.cell-output-display}\n![](exponential-glm-coverage_files/figure-commonmark/unnamed-chunk-2-3.png)\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCoverage for log: 0.949000\n```\n:::\n:::\n\n\n## Results\nFor any link-function, the coverage is terrible.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}