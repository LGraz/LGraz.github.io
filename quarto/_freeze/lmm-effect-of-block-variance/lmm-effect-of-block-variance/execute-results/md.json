{
  "hash": "705835f482cdd536e53d4f51bd12f780",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Does the variance of the Random-Effect influence the p-values?\nauthor: Lukas Graz\ndate: 2023-12-18\npermalink: /posts/lmm-effect-of-block-variace\ntags: \n  - simulation\n  - power\n---\n\n\n\nWe study the classical setup of a randomized complete block design with 2 treatments, 2 replications per block and 5 blocks. We vary the variance of the block effect and study how the p-values of the treatment effect change.\n\n$$\n% equatiomatic::extract_eq(fit)\n\\begin{aligned}\n  \\operatorname{y}_{i}  &\\sim N \\left(\\alpha_{block(i)} + \\beta_{trt(i)}, \\sigma^2 \\right) \\\\\n    \\alpha_{j}  &\\sim N \\left(\\mu_{\\alpha_{j}}, {\\sigma_{\\alpha_{j}}}^2 \\right)\n    \\text{, for block j = 1,} \\dots \\text{,5}\\\\\n    % contr sum for \\beta_{trt(i)}:\n    \\beta_{1}  &= - \\beta_{2}  \\quad \\text{(contr.sum)}\n\\end{aligned}\n$$\n\n### TLDR\nThe p-values of the treatment effect are not influenced by the variance of the block effect in our example.\n\n## Simulate Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(lmerTest)\nlibrary(multcomp)\n\noptions(contrasts = c(\"contr.sum\", \"contr.poly\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# simulate data for a linear mixed model\n# a randomized complete block design with 3 treatments, nblock blocks, nrep replicates per block\n# an observation error with standard deviation SD_noise and a block effect with standard deviation SD_block\n# a treatment effect with standard deviation SD_trt\nget_data <- function(nblock=5, nrep=2, SD_noise=3, SD_block=1, SD_trt=0) {\n  data <- expand.grid(\n    nrep = 1:nrep,\n    trt = as.factor(1:2),\n    block = as.factor(1:nblock)\n  )\n  block_effect <- SD_block * rnorm(nblock)[data$block]\n  noise <- SD_noise * rnorm(nrow(data))\n  trt_effect <- SD_trt * rnorm(nrow(data))[data$trt]\n  data$y <- trt_effect + block_effect + noise\n  data\n}\n```\n:::\n\n\n\n## Plot Function\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# function that makes an interactions plot\nplot_interactions <- function(data, ...) {\n  with(data,\n  interaction.plot(\n      x.factor = trt,\n      trace.factor = block,\n      response = y,\n      type = \"b\",\n      legend = FALSE,\n      ...\n    )\n  )\n}\n```\n:::\n\n\n\n\n## Perform Analysis\n1. Get Data that only differs with respect to SD_block (increasing)  \n2. Plot the data for each SD_block \n3. Fit a model with lmer and lm for each SD_block  \n4. inspect how the estimates and standard errors of the treatmenteffect change with increasing SD_block  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSD_blocks <- 0:8\nfits <- vector(\"list\", length(SD_blocks)*2)\ndim(fits) <- c(length(SD_blocks), 2)\ndimnames(fits) <- list(paste0(\"SD_block=\",as.character(SD_blocks)), c(\"lmer\", \"lm\"))\n\npar(mfrow=c(3,3))\nfor(i in seq_along(SD_blocks)){\n  SD_block <- SD_blocks[i]\n\n  set.seed(2)\n  data <- get_data(SD_block=SD_block)\n  plot_interactions(data, main=paste0(\"SD_block=\", SD_block))\n  \n  # lmer\n  fits[[i,1]] <- lmer(y ~ trt + (1|block), data=data)\n  \n  # lm\n  fits[[i,2]] <- lm(y ~ trt + block, data=data)\n}; par(mfrow=c(1,1))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> boundary (singular) fit: see help('isSingular')\n#> boundary (singular) fit: see help('isSingular')\n#> boundary (singular) fit: see help('isSingular')\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](lmm-effect-of-block-variance_files/figure-commonmark/unnamed-chunk-4-1.png)\n:::\n\n```{.r .cell-code}\n# apply a function to each element of a list-array\n# preserving the dimensions and dimnames\nelementwise_apply <- function(L, f){\n  L_applied <- lapply(L, f)\n  dim(L_applied) <- dim(L)\n  dimnames(L_applied) <- dimnames(L)\n  L_applied\n}\n\nsummary_coef_trt1 <- elementwise_apply(fits, function(fit) coef(summary(fit))[\"trt1\",])\n```\n:::\n\n\n\n## Results\nIllustration: How `summary_coef_trt1` looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary_coef_trt1[\"SD_block=5\",]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $lmer\n#>   Estimate Std. Error         df    t value   Pr(>|t|) \n#> -0.3125844  0.8561637 14.0000000 -0.3650989  0.7204942 \n#> \n#> $lm\n#>   Estimate Std. Error    t value   Pr(>|t|) \n#> -0.3125844  0.8561637 -0.3650989  0.7204942\n```\n\n\n:::\n\n```{.r .cell-code}\n# estimate\nelementwise_apply(summary_coef_trt1, function(coef) coef[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>            lmer       lm        \n#> SD_block=0 -0.3125844 -0.3125844\n#> SD_block=1 -0.3125844 -0.3125844\n#> SD_block=2 -0.3125844 -0.3125844\n#> SD_block=3 -0.3125844 -0.3125844\n#> SD_block=4 -0.3125844 -0.3125844\n#> SD_block=5 -0.3125844 -0.3125844\n#> SD_block=6 -0.3125844 -0.3125844\n#> SD_block=7 -0.3125844 -0.3125844\n#> SD_block=8 -0.3125844 -0.3125844\n```\n\n\n:::\n\n```{.r .cell-code}\n# standard error\nelementwise_apply(summary_coef_trt1, function(coef) coef[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>            lmer      lm       \n#> SD_block=0 0.7997087 0.8561637\n#> SD_block=1 0.7588929 0.8561637\n#> SD_block=2 0.7842232 0.8561637\n#> SD_block=3 0.8561637 0.8561637\n#> SD_block=4 0.8561637 0.8561637\n#> SD_block=5 0.8561637 0.8561637\n#> SD_block=6 0.8561637 0.8561637\n#> SD_block=7 0.8561637 0.8561637\n#> SD_block=8 0.8561637 0.8561637\n```\n\n\n:::\n\n```{.r .cell-code}\n# p-value\nelementwise_apply(summary_coef_trt1, function(coef) coef[length(coef)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>            lmer      lm       \n#> SD_block=0 0.700479  0.7204942\n#> SD_block=1 0.6852797 0.7204942\n#> SD_block=2 0.6948831 0.7204942\n#> SD_block=3 0.7204942 0.7204942\n#> SD_block=4 0.7204942 0.7204942\n#> SD_block=5 0.7204942 0.7204942\n#> SD_block=6 0.7204942 0.7204942\n#> SD_block=7 0.7204942 0.7204942\n#> SD_block=8 0.7204942 0.7204942\n```\n\n\n:::\n\n```{.r .cell-code}\n# random effect variance\nsapply(fits[,1], function(fit) VarCorr(fit)$block[1]) |> sqrt() |> signif(2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> SD_block=0 SD_block=1 SD_block=2 SD_block=3 SD_block=4 SD_block=5 SD_block=6 \n#>       0.00       0.00       0.00       0.73       2.50       3.70       4.90 \n#> SD_block=7 SD_block=8 \n#>       6.00       7.20\n```\n\n\n:::\n:::\n\n\n\n\n# Split Plot\n\nfrom: [pbkrtest-paper](https://doi.org/10.18637%2Fjss.v059.i09) section 3\n\nHarvesting dates:  \n- 1: 2/10\n- 2: 21/10  \nPlot allocation:\n|                    | Block 1        | Block 2        | Block 3        | Time        |\n|--------------------|--------------- |--------------- |--------------- |-------------|\n| Split-plots (1-15) | h1 h1 h1 h1 h1 | h2 h2 h2 h2 h2 | h1 h1 h1 h1 h1 | Harvesting |\n| Sowing (1-15)      | s3 s4 s5 s2 s1 | s3 s2 s4 s5 s1 | s5 s2 s3 s4 s1 | Sowing     |\n| Split-plots (16-30)| h2 h2 h2 h2 h2 | h1 h1 h1 h1 h1 | h2 h2 h2 h2 h2 | Harvesting |\n| Sowing (16-30)     | s2 s1 s5 s4 s3 | s4 s1 s3 s2 s5 | s1 s4 s3 s2 s5 | Sowing     |\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pbkrtest)\ndata(\"beets\", package = \"pbkrtest\")\n\nsug4 <- lmer(sugpct ~ block + sow + harvest + (1 | block:harvest), data = beets)\nanova(sug4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Type III Analysis of Variance Table with Satterthwaite's method\n#>          Sum Sq  Mean Sq NumDF DenDF  F value    Pr(>F)    \n#> block   0.01289 0.006447     2     2   2.5789    0.2794    \n#> sow     1.01000 0.252500     4    20 101.0000 5.741e-13 ***\n#> harvest 0.03803 0.038026     1     2  15.2105    0.0599 .  \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\nbeets$bh <- with(beets, interaction(block, harvest))\nsplitplot_effect <- getME(sug4, \"Z\") %*% getME(sug4, \"b\")\n# remove splitplot effect from sugpct\nbeets$sugpct_without_splitplot <- beets$sugpct - splitplot_effect[,1]\nsug_rm <- lmer(sugpct_without_splitplot ~ block + sow + harvest + (1 | block:harvest), data = beets)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> boundary (singular) fit: see help('isSingular')\n```\n\n\n:::\n\n```{.r .cell-code}\n# SPE = Split Plot Effect\neffect_multipliers <- c(0, 2^(-2:6))\nnames(effect_multipliers) <- paste0(\"SPE=\", effect_multipliers)\nsugpct_with_x_SPEs <- lapply(effect_multipliers, function(effect_multiplier) {\n  beets$sugpct_without_splitplot + effect_multiplier * splitplot_effect[,1]\n})\n\n# plot the data\nplot_list <- list() # Create an empty list to store the plots\n# Generate the plots and store them in the list\nfor(i in seq_along(sugpct_with_x_SPEs)){\n  beets$y <- sugpct_with_x_SPEs[[i]]\n  p <- ggplot(beets, aes(x = bh, y = y)) + \n  geom_boxplot() + \n  geom_jitter() +\n  ggtitle(names(effect_multipliers)[i])\n  plot_list[[i]] <- p\n}\n# Arrange the plots in a 4x2 grid\ndo.call(\"grid.arrange\", c(plot_list, ncol = 2, nrow = 5))\n```\n\n::: {.cell-output-display}\n![](lmm-effect-of-block-variance_files/figure-commonmark/unnamed-chunk-6-1.png)\n:::\n\n```{.r .cell-code}\n# for every entry in sugpct_with_x_SPE fit a mixed model and extract the p-value for the effect of harvest\nsapply(sugpct_with_x_SPEs, function(sugpct_x_SPE) {\n  fit <- lmer(sugpct_x_SPE ~ block + sow + harvest + (1 | block:harvest), data = beets)\n  c(\n    harvest = anova(fit)[\"harvest\", \"Pr(>F)\"],\n    sow = anova(fit)[\"sow\", \"Pr(>F)\"]\n  )\n})\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> boundary (singular) fit: see help('isSingular')\n#> boundary (singular) fit: see help('isSingular')\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                SPE=0     SPE=0.25      SPE=0.5        SPE=1        SPE=2\n#> harvest 1.999960e-06 2.561745e-06 3.051677e-02 5.989785e-02 1.357533e-01\n#> sow     4.421957e-14 6.306219e-14 5.741162e-13 5.741161e-13 5.741161e-13\n#>                SPE=4        SPE=8       SPE=16       SPE=32       SPE=64\n#> harvest 3.002927e-01 5.340510e-01 7.360846e-01 8.617984e-01 9.297002e-01\n#> sow     5.741161e-13 5.741161e-13 5.741161e-13 5.741161e-13 5.741161e-13\n```\n\n\n:::\n\n```{.r .cell-code}\n# analog but using the lm function\nsapply(sugpct_with_x_SPEs, function(sugpct_x_SPE) {\n  lm(sugpct_x_SPE ~ 0 + bh + sow, data = beets) |> \n    glht(linfct = matrix(c(1,1,1,-1,-1,-1,0,0,0,0)/6, nrow = 1)) |> \n    summary() |> \n    coef()\n}) #==> stays the same\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    SPE=0.1 SPE=0.25.1  SPE=0.5.1    SPE=1.1    SPE=2.1    SPE=4.1    SPE=8.1 \n#> 0.05666667 0.05666667 0.05666667 0.05666667 0.05666667 0.05666667 0.05666667 \n#>   SPE=16.1   SPE=32.1   SPE=64.1 \n#> 0.05666667 0.05666667 0.05666667\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}